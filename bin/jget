#!/usr/bin/env python

import os, sys

from twisted.application.app import ReactorSelectionMixin
from twisted.conch.ssh.agent import SSHAgentClient, SSHAgentServer
from twisted.internet.defer import inlineCallbacks, returnValue
from twisted.internet.protocol import ClientCreator
from twisted.protocols.loopback import loopbackAsync
from twisted.python import usage
from twisted.python.filepath import FilePath

from zope.interface import implements

from jersey import cli, log

from pendrell.agent import Agent
from pendrell.auth import IAuthenticator
from pendrell.error import WebError, UnauthorizedResponse
from pendrell.util import URLPath



class AuthAgentClient(SSHAgentClient):

    def __init__(self, *args, **kw):
        SSHAgentClient.__init__(self, *args, **kw)
        self.keys = []


    @inlineCallbacks
    def requestIdentities(self):
        self.keys = k = yield SSHAgentClient.requestIdentities(self)
        returnValue(k)



class PubKeyAuthenticator(object):
    implements(IAuthenticator)

    schemes = ("PubKey.v1", )
    secure = True

    def __init__(self, identifier, agent, pubKey):
        self.identifier = identifier
        self.agent = agent
        self.pubKey = pubKey


    @inlineCallbacks
    def authorize(self, scheme, **params):
        cred = {"challenge": params["challenge"],
                "realm": params["realm"],
                "id": self.identifier,
                }
        cred["signature"] = yield self.signAuth(cred)

        auth = ", ".join(["{0}=\"{1}\"".format(*i) for i in cred.items()])
        log.debug("Authenticating: {0}".format(auth))
        returnValue("{0} {1}".format(scheme, auth))


    @inlineCallbacks
    def signAuth(self, auth):
        data = auth["challenge"]
        signature = yield self.agent.signData(self.pubKey, data)
        returnValue(signature.encode("base64").replace("\n", ""))



class JGetOptions(cli.Options, ReactorSelectionMixin):

    optParameters = [
        ["user", "u", os.getlogin(), "Login user"],
        ["auth-sock", "A", os.getenv("JERSEY_AUTH_SOCK"),
                "Authentication socket"],
        ]

    optFlags = [
        ["debug", "D", "Be debuggy."]
        ]


    def parseArgs(self, url):
        try:
            self["url"] = URLPath.fromString(url)
        except Exception, e:
            raise usage.error("Invalid URL: {0}: {1}".format(url, *e.args))


    def postOptions(self):
        if not self["auth-sock"]:
            raise usage.error("No authentication socket specified.")
        if self["debug"]:
            self.logLevel = log.DEBUG



class JGetCommand(cli.Command):

    def __init__(self, config):
        cli.Command.__init__(self, config)

        self.config = config
        self.url = config["url"]
        self.username = config["user"]
        self.authSock = config["auth-sock"]


    def buildAuthAgent(self):
        from twisted.internet import reactor
        creator = ClientCreator(reactor, AuthAgentClient)
        log.trace("Connecting to auth socket: {0}".format(self.authSock))
        return creator.connectUNIX(self.authSock)


    def buildWebAgent(self):
        log.trace("Building a Web agent.")
        return Agent()


    @inlineCallbacks
    def execute(self):
        if self.authSock and FilePath(self.authSock).exists():
            try:
                authAgent = yield self.buildAuthAgent()
                keys = yield authAgent.requestIdentities()
            except Exception, e:
                log.warn(e)
                keys = []
        else:
            keys = []

        if len(keys) == 0:
            authAgent = None

        webAgent = self.buildWebAgent()

        try:
            if authAgent:
                response = yield self._issueAuthenticatedRequest(authAgent, webAgent)
            else:
                response = yield self._issueRequest(webAgent)

        except WebError, we:
            print >>sys.stderr, "{0.url}: {1[0]}: {1[1]}".format(self, we.args)
            self.exitValue = 1

        except:
            log.err()
            self.exitValue = 2

        else:
            sys.stdout.write(response.content)
            sys.stdout.flush()
            self.exitValue = os.EX_OK


    def _issueRequest(self, webAgent):
        return webAgent.open(self.url)


    @inlineCallbacks
    def _issueAuthenticatedRequest(self, authAgent, webAgent):
        keys = authAgent.keys[:]
        authenticated = False
        err = None

        while keys and not authenticated:
            key = keys.pop()[0]
            auth = PubKeyAuthenticator(self.username, authAgent, key)
            try:
                response = yield webAgent.open(self.url, authenticator=auth)
            except UnauthorizedResponse, ur:
                err = ur
            else:
                # TODO Cache known good (url,key) pairs...
                authenticated = True

        if not authenticated:
            assert err is not None
            raise err

        returnValue(response)



if __name__ == "__main__":
    binDir, progName = os.path.split(sys.argv[0])
    args = sys.argv[1:]

    opts = JGetOptions(progName)
    try:
        opts.parseOptions(args)

        cmd = JGetCommand(opts)
        runner = cli.CommandRunner(progName, opts, cmd)

        runner.run()

    except usage.error, ue:
        print >>sys.stderr, "{1!s}\n{0}: {2!s}".format(progName, opts, ue)
        raise SystemExit(os.EX_USAGE)

    else:
        raise SystemExit(vtwt.exitValue)



# vim: ft=python ts=4 sw=4

